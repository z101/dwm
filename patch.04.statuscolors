diff --git a/config.def.h b/config.def.h
index ec7e0fd..b5655d4 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,6 +1,20 @@
 /* See LICENSE file for copyright and license details. */
 
 /* appearance */
+#define NUMCOLORS 10
+static const char colors[NUMCOLORS][MAXCOLORS][8] = {
+   // border foreground background
+   { "#202020", "#777777", "#202020" }, // normal
+   { "#202020", "#eeeeec", "#202020" }, // selected
+   { "#202020", "#fce94f", "#202020" }, // warning
+   { "#cc0000", "#eeeeec", "#cc0000" }, // error
+   { "#202020", "#bbbbbb", "#202020" }, // info
+   { "#202020", "#4e9a06", "#202020" }, // ok
+   { "#202020", "#3465a4", "#202020" }, // highlight
+   { "#202020", "#777777", "#202020" }, // normal
+   { "#202020", "#777777", "#202020" }, // normal
+   { "#202020", "#777777", "#202020" }, // normal
+};
 static const char *fonts[] = {
 	"monospace:size=10"
 };
diff --git a/drw.c b/drw.c
index f49200b..461976c 100644
--- a/drw.c
+++ b/drw.c
@@ -206,6 +206,110 @@ drw_setscheme(Drw *drw, ClrScheme *scheme)
 	drw->scheme = scheme;
 }
 
+int
+drw_get_width(Drw *drw, const char *text)
+{
+	char buf[1024];
+	int i, len = 0;
+
+	for (i = 0; text[i] != 0; i++) {
+		if (text[i] == '\\' && text[i+1] == 'c' && text[i+2] >= '0' && text[i+2] <= '9') {
+			i += 3;
+		}
+		
+		len++;
+	}
+
+	for (i = 0; i < len; i++) {
+		buf[i] = '.';
+	}
+	buf[len] = '\0';
+
+	return drw_text(drw, 0, 0, 0, 0, buf, 0) + 1;
+}
+
+int
+drw_status_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int invert)
+{
+	char buf[1024];
+	int tx, ty, th;
+	Extnts tex;
+	XftDraw *d = NULL;
+	Fnt *curfont;
+	size_t i, len;
+	int utf8strlen, utf8charlen;
+	long utf8codepoint = 0;
+	const char *utf8str;
+
+	XSetForeground(drw->dpy, drw->gc, invert ?
+				   drw->scheme->fg->pix : drw->scheme->bg->pix);
+	XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+	d = XftDrawCreate(drw->dpy, drw->drawable,
+					  DefaultVisual(drw->dpy, drw->screen),
+					  DefaultColormap(drw->dpy, drw->screen));
+
+	curfont = drw->fonts[0];
+	utf8strlen = 0;
+	utf8str = text;
+	while (*text) {
+		utf8charlen = utf8decode(text, &utf8codepoint, UTF_SIZ);
+		utf8strlen += utf8charlen;
+		text += utf8charlen;
+	}
+
+	if (utf8strlen) {
+		drw_font_getexts(curfont, utf8str, utf8strlen, &tex);
+		/* shorten text if necessary */
+		for (len = MIN(utf8strlen, (sizeof buf) - 1); len && (tex.w > w - drw->fonts[0]->h || w < drw->fonts[0]->h); len--)
+			drw_font_getexts(curfont, utf8str, len, &tex);
+
+		if (len) {
+			memcpy(buf, utf8str, len);
+			buf[len] = '\0';
+			if (len < utf8strlen)
+				for (i = len; i && i > len - 3; buf[--i] = '.');
+
+			th = curfont->ascent + curfont->descent;
+			ty = y + (h / 2) - (th / 2) + curfont->ascent;
+			tx = x;// + (h / 2);
+			XftDrawStringUtf8(d, invert ? &drw->scheme->bg->rgb : &drw->scheme->fg->rgb, curfont->xfont, tx, ty, (XftChar8 *)buf, len);
+			x += tex.w;
+		}
+	}
+
+	if (d)
+		XftDrawDestroy(d);
+
+	return x;
+}
+
+void
+drw_colored_text(Drw *drw, ClrScheme *scheme, int x, int y, unsigned int w, unsigned int h, char *text)
+{
+	char buf[1024];
+	int i, j, coloridx = 0;
+
+	drw_setscheme(drw, &scheme[0]);
+	for (i = 0, j = 0; text[i] != 0; i++) {
+		if (text[i] == '\\' && text[i+1] == 'c' && text[i+2] >= '0' && text[i+2] <= '9') {
+			coloridx = text[i+2] - '0';
+			i += 3;
+			buf[j] = '\0';
+
+			x = drw_status_text(drw, x, y, w, h, buf, 0);
+			drw_setscheme(drw, &scheme[coloridx]);
+
+			j = 0;
+		}
+		
+		buf[j] = text[i];
+		j++;
+	}
+	buf[j] = '\0';
+	drw_setscheme(drw, &scheme[coloridx]);
+	x = drw_status_text(drw, x, y, w, h, buf, 0);
+}
+
 void
 drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int empty, int invert)
 {
diff --git a/drw.h b/drw.h
index e3b8515..1aaefb9 100644
--- a/drw.h
+++ b/drw.h
@@ -67,6 +67,9 @@ void drw_setfont(Drw *, Fnt *);
 void drw_setscheme(Drw *, ClrScheme *);
 
 /* Drawing functions */
+int drw_get_width(Drw *, const char *);
+int drw_status_text(Drw *, int, int, unsigned int, unsigned int, const char *, int);
+void drw_colored_text(Drw *, ClrScheme *, int, int, unsigned int, unsigned int, char *);
 void drw_rect(Drw *, int, int, unsigned int, unsigned int, int, int, int);
 int drw_text(Drw *, int, int, unsigned int, unsigned int, const char *, int);
 
diff --git a/dwm.c b/dwm.c
index 1cbbd5e..af666eb 100644
--- a/dwm.c
+++ b/dwm.c
@@ -51,6 +51,7 @@
                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
 #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
 #define LENGTH(X)               (sizeof X / sizeof X[0])
+#define MAXCOLORS               10
 #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
@@ -263,7 +264,7 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 static Atom wmatom[WMLast], netatom[NetLast];
 static int running = 1;
 static Cur *cursor[CurLast];
-static ClrScheme scheme[SchemeLast];
+static ClrScheme scheme[MAXCOLORS];
 static Display *dpy;
 static Drw *drw;
 static Monitor *mons, *selmon;
@@ -760,35 +761,35 @@ drawbar(Monitor *m)
 	x = 0;
 	for (i = 0; i < LENGTH(tags); i++) {
 		w = TEXTW(tags[i]);
-		drw_setscheme(drw, m->tagset[m->seltags] & 1 << i ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
-		drw_text(drw, x, 0, w, bh, tags[i], urg & 1 << i);
+		drw_setscheme(drw, &scheme[(m->tagset[m->seltags] & 1 << i) ? 1 : (urg & 1 << i ? 2 : 0)]);
+		drw_text(drw, x, 0, w, bh, tags[i], 0);
 		drw_rect(drw, x + 1, 1, dx, dx, m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
-		           occ & 1 << i, urg & 1 << i);
+		         occ & 1 << i, 0);
 		x += w;
 	}
 	w = blw = TEXTW(m->ltsymbol);
-	drw_setscheme(drw, &scheme[SchemeNorm]);
+	drw_setscheme(drw, &scheme[0]);
 	drw_text(drw, x, 0, w, bh, m->ltsymbol, 0);
 	x += w;
 	xx = x;
 	if (m == selmon) { /* status is only drawn on selected monitor */
-		w = TEXTW(stext);
+		w = drw_get_width(drw, stext);
 		x = m->ww - w;
 		if (x < xx) {
 			x = xx;
 			w = m->ww - xx;
 		}
-		drw_text(drw, x, 0, w, bh, stext, 0);
+		drw_colored_text(drw, scheme, x + 1, 0, w, bh, stext);
 	} else
 		x = m->ww;
 	if ((w = x - xx) > bh) {
 		x = xx;
 		if (m->sel) {
-			drw_setscheme(drw, m == selmon ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
+			drw_setscheme(drw, &scheme[m == selmon ? 1 : 0]);
 			drw_text(drw, x, 0, w, bh, m->sel->name, 0);
 			drw_rect(drw, x + 1, 1, dx, dx, m->sel->isfixed, m->sel->isfloating, 0);
 		} else {
-			drw_setscheme(drw, &scheme[SchemeNorm]);
+			drw_setscheme(drw, &scheme[0]);
 			drw_rect(drw, x, 0, w, bh, 1, 0, 1);
 		}
 	}
@@ -849,7 +850,7 @@ focus(Client *c)
 		detachstack(c);
 		attachstack(c);
 		grabbuttons(c, 1);
-		XSetWindowBorder(dpy, c->win, scheme[SchemeSel].border->pix);
+		XSetWindowBorder(dpy, c->win, scheme[1].border->pix);
 		setfocus(c);
 	} else {
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
@@ -1107,7 +1108,7 @@ manage(Window w, XWindowAttributes *wa)
 
 	wc.border_width = c->bw;
 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-	XSetWindowBorder(dpy, w, scheme[SchemeNorm].border->pix);
+	XSetWindowBorder(dpy, w, scheme[0].border->pix);
 	configure(c); /* propagates border_width, if size doesn't change */
 	updatewindowtype(c);
 	updatesizehints(c);
@@ -1591,6 +1592,7 @@ setmfact(const Arg *arg)
 void
 setup(void)
 {
+	int i;
 	XSetWindowAttributes wa;
 
 	/* clean up any zombies immediately */
@@ -1625,12 +1627,12 @@ setup(void)
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
 	/* init appearance */
-	scheme[SchemeNorm].border = drw_clr_create(drw, normbordercolor);
-	scheme[SchemeNorm].bg = drw_clr_create(drw, normbgcolor);
-	scheme[SchemeNorm].fg = drw_clr_create(drw, normfgcolor);
-	scheme[SchemeSel].border = drw_clr_create(drw, selbordercolor);
-	scheme[SchemeSel].bg = drw_clr_create(drw, selbgcolor);
-	scheme[SchemeSel].fg = drw_clr_create(drw, selfgcolor);
+	for(i = 0; i < NUMCOLORS; i++){
+		scheme[i].border = drw_clr_create(drw, colors[i][0]);
+		scheme[i].fg = drw_clr_create(drw, colors[i][1]);
+		scheme[i].bg = drw_clr_create(drw, colors[i][2]);
+	}
+
 	/* init bars */
 	updatebars();
 	updatestatus();
@@ -1812,7 +1814,7 @@ unfocus(Client *c, int setfocus)
 	if (!c)
 		return;
 	grabbuttons(c, 0);
-	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm].border->pix);
+	XSetWindowBorder(dpy, c->win, scheme[0].border->pix);
 	if (setfocus) {
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
 		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
